#include "DenseNetwork.h"
#include <armadillo>

DenseNetwork::DenseNetwork(arma::cube * data)
{
    flatten_data(data);
    
    //Random seed for initializing weights
	std::random_device rd;
	
	//Uniform distribution of real numbers
	std::normal_distribution<double> distr(0, 1);

	//dense layer weights
	weights1 = arma::mat(this->data.n_cols, 384);
	weights2 = arma::mat(384, 32);
	weights3 = arma::mat(32, 8);
	
	//mersenne twister engine for generating random values
	std::mt19937 engine(rd());
	//filling weight matrices with random values generated by mersenne engine by cell
	weights1.imbue( [&]() {return distr(engine) * 2 / (this->data.n_cols); } );
	engine.seed(rd());
	weights2.imbue( [&]() {return distr(engine) * 2 / (384); } );
	engine.seed(rd());
	weights3.imbue( [&]() {return distr(engine) * 2 / (32); } );
}

void DenseNetwork::set_data(arma::cube * data)
{
    flatten_data(data);
}

void DenseNetwork::flatten_data(arma::cube * data)
{
    //vectorizing slices and combining 
    this->data = arma::mat(data->n_slices, data->n_cols * data->n_rows);
    for(arma::uword i = 0; i < data->n_slices; i++)
    {
        this->data.row(i) = arma::vectorise(data->slice(i), 1);
    }
}

arma::mat DenseNetwork::calculate_output(void (*activation_func)(arma::mat *, const char *), void (*batch_norm)(arma::mat *))
{
    arma::mat results = this->data * weights1;
    activation_func(&results, "relu");
    batch_norm(&results);
    
    results = results * weights2;
    activation_func(&results, "relu");
    batch_norm(&results);

    results = results * weights3;
    activation_func(&results, "softmax");

    return results;
}

DenseNetwork::~DenseNetwork()
{
}